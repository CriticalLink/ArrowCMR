/*****************************************************************************
Copyright (c) 2019 - Analog Devices Inc. All Rights Reserved.
This software is proprietary & confidential to Analog Devices, Inc.
and its licensors.
******************************************************************************
File Name : qep.c

Generation Date: 2019-01-09
Generated By: Jens Sorensen

Description:

*****************************************************************************/

/*=============  I N C L U D E S   =============*/
#include <stdint.h>
#include "rtwtypes.h"

/*=============  D E F I N E S   =============*/
#define QEP_BASE 0xFF202000

// M -> S
#define REG_QEP_CONFIG 0
#define REG_QEP_MPW_CNT 1
#define REG_QEP_CNT_WRAP 2
#define REG_QEP_RESET 3
#define REG_QEP_ENABLE 4
#define REG_QEP_M 5

// S -> M
#define REG_QEP_CNT 16
#define REG_QEP_CNT_IDX_LATCH 17
#define REG_QEP_CNT_STROBE_LATCH 18
#define REG_QEP_HALL 19
#define REG_QEP_N_BY_M 20
#define REG_QEP_N_BY_1 21
#define REG_QEP_N_BY_M_STROBE_LATCH 22
#define REG_QEP_N_BY_1_STROBE_LATCH 23
#define REG_QEP_PER_CNT_N_BY_M 24
#define REG_QEP_PER_CNT_N_BY_1 25
#define REG_QEP_DIRECTION 26
#define REG_QEP_DIRECTION_STROBE_LATCH  27

// Minimum pulse-width filter on ABZ and Hall UVW lines
#define MPW_CNT_LIM     256    // 2.56 us @ 100 MHz clock
#define CNT_WRAP 		3999
#define M 				4

void QEP_IP_mWriteReg(uint32_t base, uint32_t offset, uint32_t val) { 
	volatile uint32_t* reg = (volatile uint32_t*)(base);
	reg[offset] = val;
}

uint32_t QEP_IP_mReadReg(uint32_t base, uint32_t offset) {
	volatile uint32_t* reg = (volatile uint32_t*)(base);
	return reg[offset];
}

/*=============  P R O T O T Y P E S  =============*/

/*=============  D A T A  =============*/

/*=============  C O D E  ==================*/
void aInitIncEnc(void){
/*****************************************************************************
  Function: aInitIncEnc

  Parameters: None

  Returns: None

  Notes:

*****************************************************************************/
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_RESET, 0x1);
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_CONFIG, 0x40);
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_MPW_CNT, MPW_CNT_LIM);
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_CNT_WRAP, CNT_WRAP);
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_M, M);
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_RESET, 0x0);
	QEP_IP_mWriteReg(QEP_BASE, REG_QEP_ENABLE, 0x1);
}

void GetQepRegs(uint32_T* cnt_reg, uint32_T* N_by_M_reg, uint32_T* N_by_1_reg, int8_T* dir_reg){
/*****************************************************************************
  Function: GetQepCnt

  Parameters: None

  Returns:

  Notes: This functions returns a snapshot of encoder registers. This is a
         standard read with no synchronization to other events/triggers

*****************************************************************************/
  uint32_t per_cnt_temp=0;
  uint32_t n_by_x_temp=0;
  uint8_t dir_temp=0;

  *cnt_reg = QEP_IP_mReadReg(QEP_BASE, REG_QEP_CNT);

  n_by_x_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_N_BY_M);
  per_cnt_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_PER_CNT_N_BY_M);

  if (per_cnt_temp > n_by_x_temp)
	*N_by_M_reg = per_cnt_temp;
  else
	*N_by_M_reg = n_by_x_temp;

  n_by_x_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_N_BY_1);
  per_cnt_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_PER_CNT_N_BY_1);

  if (per_cnt_temp > n_by_x_temp)
	*N_by_1_reg = per_cnt_temp;
  else
	*N_by_1_reg = n_by_x_temp;

  dir_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_DIRECTION);

  if(dir_temp)
	*dir_reg=-1;
  else
	*dir_reg=1;
}

void GetQepRegsStrobeLatch(uint32_T* cnt_reg, uint32_T* N_by_M_reg, uint32_T* N_by_1_reg, int8_T* dir_reg){
/*****************************************************************************
  Function: GetQepCntStrobeLatch

  Parameters: None

  Returns:

  Notes: This functions returns the encoder registers captured at the strobe signal (PWM_SYNC)

*****************************************************************************/
  uint32_t per_cnt_temp=0;
  uint32_t n_by_x_temp=0;
  uint8_t dir_temp=0;

  *cnt_reg = QEP_IP_mReadReg(QEP_BASE, REG_QEP_CNT_STROBE_LATCH);

  n_by_x_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_N_BY_M_STROBE_LATCH);
  per_cnt_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_PER_CNT_N_BY_M);

  if (per_cnt_temp > n_by_x_temp)
	*N_by_M_reg = per_cnt_temp;
  else
	*N_by_M_reg = n_by_x_temp;

  n_by_x_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_N_BY_1_STROBE_LATCH);
  per_cnt_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_PER_CNT_N_BY_1);

  if (per_cnt_temp > n_by_x_temp)
	*N_by_1_reg = per_cnt_temp;
  else
	*N_by_1_reg = n_by_x_temp;

  dir_temp = QEP_IP_mReadReg(QEP_BASE, REG_QEP_DIRECTION_STROBE_LATCH);

  if(dir_temp)
	*dir_reg=-1;
  else
	*dir_reg=1;
}

uint16_t GetHallState(void){
/*****************************************************************************
  Function: GetHallState

  Parameters: None

  Returns: hall state

  Notes: Maps hall states into 3-bit grey code

*****************************************************************************/
  uint16_t hall_temp = 0;

  hall_temp = (uint16_t)QEP_IP_mReadReg(QEP_BASE, REG_QEP_HALL);

  return hall_temp;
}
