/*******************************************************************************
Copyright (c) 2016 - Analog Devices Inc. All Rights Reserved.
This software is proprietary & confidential to Analog Devices, Inc.
and its licensors.
 ********************************************************************************
File Name: platform.c

Generation Date: 2016-10-24
Generated By: Christian Aaen
 *******************************************************************************/
#include <stdio.h>
#include "platform.h"
#include <stddef.h>
#include "hwlib.h"
#include "alt_cache.h"
#include "alt_mmu.h"
#include "alt_address_space.h"
#include "alt_timers.h"
#include "alt_clock_manager.h"
#include <stdlib.h>

#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
#define BOOT_CHECK_STATUS       boot_check_status(status, __FILE__, __LINE__)
void boot_check_status(ALT_STATUS_CODE status, char *file, int line) {

	if(status != ALT_E_SUCCESS) {
		static char buff[128];
		sprintf(buff,"%s:%d ERROR %lu \r\n", file, line,status);
		failExit(buff);
	}
	//printf("%s:%d\r\n", file, line);
}

void failExit(const char*msg)
{
	static int leds[7] = { GPIO_LED1, GPIO_LED2, GPIO_LED3, GPIO_LED4, GPIO_LED5, GPIO_LED6,GPIO_LED7};
	int state = 0;
	printf("FAIL ... LOOP FOREVER!!!\r\n");
	if(msg) {
		printf("%s\r\n",msg);
	}
	for(;;) {
		for(int ii = 0; ii < ARRAY_SIZE(leds); ++ii) {
			SetLed(ii,state);
		}
		for(volatile int ii = 0; ii < 1000000; ++ii);
		state = ! state;
	}
}


/* MMU Page table - 16KB aligned at 16KB boundary */
uint32_t __attribute__ ((aligned (0x4000))) alt_pt_storage[4096];

static void *alt_pt_alloc(const size_t size, void *context)
{
	return context;
}

static ALT_STATUS_CODE mmu_init(void)
{
	uint32_t *ttb1 = NULL;
	ALT_STATUS_CODE status = ALT_E_SUCCESS;

	/* Populate the page table with sections (1 MiB regions). */
	ALT_MMU_MEM_REGION_t regions[] = {
			/* Memory area: 1 GiB */
			{
					.va         = (void *)0x00000000,
					.pa         = (void *)0x00000000,
					.size       = 0x40000000,
					.access     = ALT_MMU_AP_FULL_ACCESS,
					.attributes = ALT_MMU_ATTR_WBA,
					.shareable  = ALT_MMU_TTB_S_NON_SHAREABLE,
					.execute    = ALT_MMU_TTB_XN_DISABLE,
					.security   = ALT_MMU_TTB_NS_SECURE
			},

			/* Device area: Everything else */
			{
					.va         = (void *)0x40000000,
					.pa         = (void *)0x40000000,
					.size       = 0xc0000000,
					.access     = ALT_MMU_AP_FULL_ACCESS,
					.attributes = ALT_MMU_ATTR_DEVICE,
					.shareable  = ALT_MMU_TTB_S_NON_SHAREABLE,
					.execute    = ALT_MMU_TTB_XN_ENABLE,
					.security   = ALT_MMU_TTB_NS_SECURE
			}
	};
	status = alt_mmu_init();
	BOOT_CHECK_STATUS;
	status = alt_mmu_disable();
	BOOT_CHECK_STATUS;

	size_t reqsize = alt_mmu_va_space_storage_required(regions,
			ARRAY_SIZE(regions));
	if (reqsize > sizeof(alt_pt_storage))
		status = ALT_E_ERROR;
	BOOT_CHECK_STATUS;

	status = alt_mmu_va_space_create(&ttb1, regions, ARRAY_SIZE(regions), alt_pt_alloc, alt_pt_storage);
	BOOT_CHECK_STATUS;

	status = alt_mmu_va_space_enable(ttb1);
	BOOT_CHECK_STATUS;

	return status;
}

sfeStatus_t platformInit(void)
{
	ALT_STATUS_CODE status = ALT_E_SUCCESS;
	uint32_t freq;
	//
	// disable interrupts to this cpu since the preloader will enable ECC
	// interrupts by default for the ghrd hardware system that we are using in
	// this example.  If we don't pre-clean the memory that we may touch, we
	// are vulnerable to an ECC interrupt that would lock us up.  So we just
	// disable them.
	//
	status = alt_int_cpu_disable();
	BOOT_CHECK_STATUS;
	status = alt_int_global_disable();
	BOOT_CHECK_STATUS;
	status = alt_cache_system_disable();
	BOOT_CHECK_STATUS;

	alt_gpt_all_tmr_init();
	alt_clk_freq_get(ALT_CLK_MPU, &freq);
	printf("INFO: MPU Frequency = %lu.\r\n", freq);
	alt_clk_freq_get(ALT_CLK_DDR_DQS, &freq);
	printf("INFO: DDR Frequency = %lu.\r\n", freq);
	alt_gpio_init();
	SetLed(GPIO_LED5,1);

#if 0
	// remapping SDRAM was added as part of integration trying to get MMU configured. may not be needed.
	// may even be why the FPGA is not working correcly (no interrupts)
	//
	// remap SDRAM to the ZEROth MB of the MPU address map
	//
	status = alt_mpu_addr_space_remap_0_to_sdram();
	BOOT_CHECK_STATUS;
	//
	// remap the L3 interconnect to mark H2F and LWH2F bridges as inaccessible
	// if the FPGA is known to be programmed already then this may be
	// inappropriate, but this should be the safer thing to do at this point
	//
	status = alt_addr_space_remap(
			ALT_ADDR_SPACE_MPU_ZERO_AT_BOOTROM,
			ALT_ADDR_SPACE_NONMPU_ZERO_AT_SDRAM,
			ALT_ADDR_SPACE_H2F_INACCESSIBLE,
			ALT_ADDR_SPACE_LWH2F_INACCESSIBLE);
	BOOT_CHECK_STATUS;
#endif

	if(!SwitchState(GPIO_SW3)) {
		printf("Enabling MMU...\r\n");
		status = mmu_init();
		BOOT_CHECK_STATUS;
	}
	printf("Enabling Caches...\r\n");
	status = alt_cache_system_enable();
	BOOT_CHECK_STATUS;

	printf("Enabling Interrupts...\r\n");
	// These must be only called once (setup for being able to use interrupts)
	status = alt_int_global_init();
	BOOT_CHECK_STATUS;

	status = alt_int_cpu_init();
	BOOT_CHECK_STATUS;

	//
	// enable the GIC to pass interrupt events to the CPU
	//
	status = alt_int_global_enable();
	BOOT_CHECK_STATUS;

	status = alt_int_cpu_enable();
	BOOT_CHECK_STATUS;

	printf("Platform init complete!\r\n");

	return SFE_SUCCESS;
}
void SetLed(uint32_t led, int on)
{
	alt_gpio_port_datadir_set(ALT_GPIO_PORTB, led, on?led:0);
}

int SwitchState(uint32_t sw)
{
	// GPIO ports are input by default
	return alt_gpio_port_data_read(ALT_GPIO_PORTB, sw)&sw?1:0;
}
