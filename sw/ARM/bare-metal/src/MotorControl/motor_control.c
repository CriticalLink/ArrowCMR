/*****************************************************************************
Copyright (c) 2019 - Analog Devices Inc. All Rights Reserved.
This software is proprietary & confidential to Analog Devices, Inc.
and its licensors.
******************************************************************************
File Name : motor_control.c 

Generation Date: 2019-01-09
Generated By: Jens Sorensen 

Description: 

*****************************************************************************/
/*=============  I N C L U D E S   =============*/
#include <motor_control.h>
#include <PMSMctrl.h>          // Header file of auto generated code
#include <ADIMonitor.h>
#include <application.h>
#include <pwm.h>
#include "rtwtypes.h"
#include <measure.h>
#include <qep.h>
#include <alt_generalpurpose_io.h>

/*=============  D E F I N E S   =============*/

/*=============  P R O T O T Y P E S =============*/

/*=============  D A T A  =============*/
uint16_t duty_a, duty_b, duty_c;
uint16_t hall_state_monitor, qep_cnt_monitor;
uint32_t n_by_m_per_monitor, n_by_1_per_monitor;
uint16_t ic_sinc_raw, ib_sinc_raw;
int8_t qep_dir_monitor;

uint32_t size_check_t = sizeof(size_check_t);
uint32_T size_check_T = sizeof(size_check_T);

uint16_t ext_trip_cnt=0, sinc0_trip_cnt=0, sinc1_trip_cnt=0;

MODE_TYPE mode_act=MODE0;

/*=============  C O D E  =============*/
void aMcInit(void){
/*****************************************************************************
  Function: aMcInit
  
  Parameters: None
  
  Returns: None
  
  Notes:
  
*****************************************************************************/
  InitPWM();
  aInitIncEnc();
  aMeasureInit();
  PMSMctrl_initialize();   // Init of MBC
}

void aMcModeHandler(MODE_TYPE mode_cmd){

  if(PMSMctrl_P.SYSTEM_CMD == 0){  // Only change settings if motor is stopped

	mode_act = mode_cmd;

	if(mode_cmd == MODE0) {
		PMSMctrl_P.VF_CTRL = 0;
		SetupSincOptFlush();
	}
	else if(mode_cmd == MODE1) {
		PMSMctrl_P.VF_CTRL = 1;
		SetupSincOptFlush();
	}
	else if(mode_cmd == MODE2){
		PMSMctrl_P.VF_CTRL = 2;
		SetupSincOptFlush();
	}
	else if(mode_cmd == MODE3){
		PMSMctrl_P.VF_CTRL = 1;
		SetupSincOptContinious();
	}
	else if(mode_cmd == MODE4){
		PMSMctrl_P.VF_CTRL = 1;
		SetupSincNonOptContinious();
	}
  }
}

MODE_TYPE GetMode(void){
	return mode_act;
}

void aMcCmd(MC_EVENT command){
/*****************************************************************************
  Function: aMcInit
  
  Parameters: None
  
  Returns: None
  
  Notes:
  
*****************************************************************************/
  switch (command){
  case eMC_START:
	  EnablePWM();
	  //EnableSincTrip();
    break;
  case eMC_STOP:
	  DisablePWM();
    break;
  default:
    break;
  }
}

void sMcTask(void){
/*****************************************************************************
  Function: sMcTask
  
  Parameters: None
  
  Returns: None
  
  Notes:
  
*****************************************************************************/
  uint8_t trip_status = 0;
  uint8_t trip_level = 0;
  uint8_t trip_source = 0;

  trip_status = GetPwmTripStatus(); // Check for fault

  if(trip_status){
	  trip_source = GetPwmTripSource(); // Get the source of the trip. Note, it's possible multiple trip sources are active at the same time so check all

    if (trip_source & BITM_EXT_TRIP){
	  trip_level = GetPwmTripPinLevel();
	  if(trip_level){  // trip is active low. trip_level=1 means it's safe to clear
		ClearPwmTrip();
		ext_trip_cnt++;
	  }
    }
    if (trip_source & BITM_SINC0_TRIP){
	  ClearSincTrip();
	  ClearPwmTrip();
	  sinc0_trip_cnt++;
    }
    if (trip_source & BITM_SINC1_TRIP_MASK){
	  ClearSincTrip();
	  ClearPwmTrip();
	  sinc1_trip_cnt++;
    }
    if (trip_source==0){
	  ClearSincTrip();
	  ClearPwmTrip();
    }
  }
}

void sMcAlgorithm(void){
/*****************************************************************************
  Function: sMcAlgorithm
  
  Parameters: None
  
  Returns: None
  
  Notes: This function schedules and calls MBC functions. It also assigns values
  to MBC inputs and handles apply MBC outputs.
  
*****************************************************************************/
  static boolean_T eventFlags[2] = { 0, 0 };/* Model has 2 rates */
  static uint16_t taskCounter[2] = { 0, 0 };
  duty_type ref;

  PMSMctrl_U.Vdc_adc = 24.0;
  PMSMctrl_U.ibc_sinc[1] = GetSincData(0);
  PMSMctrl_U.ibc_sinc[0] = GetSincData(1);
  ic_sinc_raw = GetSincData(1); // PMSMctrl_U.ibc_sinc[0];
  ib_sinc_raw = GetSincData(0); //PMSMctrl_U.ibc_sinc[1];

  PMSMctrl_U.hall_state = GetHallState();
  hall_state_monitor = PMSMctrl_U.hall_state; // Just for display

  //GetQepRegs(&PMSMctrl_U.QEP_cnt, &PMSMctrl_U.N_by_M, &PMSMctrl_U.N_by_1, &PMSMctrl_U.ROT_DIR_meas);
  GetQepRegsStrobeLatch(&PMSMctrl_U.QEP_cnt, &PMSMctrl_U.N_by_M, &PMSMctrl_U.N_by_1, &PMSMctrl_U.ROT_DIR_meas);

  qep_cnt_monitor = (uint16_t)PMSMctrl_U.QEP_cnt;           // Just for display
  n_by_m_per_monitor = PMSMctrl_U.N_by_M;
  n_by_1_per_monitor = PMSMctrl_U.N_by_1;
  qep_dir_monitor = (int8_t)PMSMctrl_U.ROT_DIR_meas;
    
  /* Step the model for base rate */
  static bool gpio7_state = false;
  gpio7_state = !gpio7_state;
  if (gpio7_state) {
    alt_gpio_port_datadir_set(ALT_GPIO_PORTB, GPIO_LED7, 0);
  } else {
    alt_gpio_port_datadir_set(ALT_GPIO_PORTB, GPIO_LED7, GPIO_LED7);
  }
  alt_gpio_port_datadir_set(ALT_GPIO_PORTB, GPIO_LED3, GPIO_LED3);
  PMSMctrl_step0();
  alt_gpio_port_datadir_set(ALT_GPIO_PORTB, GPIO_LED3, 0);
  
  if ((taskCounter[1] == 0))
    eventFlags[1] = true;
  
  if (eventFlags[1]) {  /* Step the model for subrate 1 */
    static bool gpio6_state = false;
    gpio6_state = !gpio6_state;
    if (gpio6_state) {
      alt_gpio_port_datadir_set(ALT_GPIO_PORTB, GPIO_LED6, 0);
    } else {
      alt_gpio_port_datadir_set(ALT_GPIO_PORTB, GPIO_LED6, GPIO_LED6);
    }
    PMSMctrl_step1();
    sAppTask();
    eventFlags[1] = false;  /* Indicate task complete for subrate */
  }
  
  taskCounter[1]++;
  if (taskCounter[1] == 10)
    taskCounter[1] = 0;
  
  duty_a = PMSMctrl_Y.cnt_a; // Just for display in ADIMonitor
  duty_b = PMSMctrl_Y.cnt_b;
  duty_c = PMSMctrl_Y.cnt_c;

  ref.duty_a = duty_a;
  ref.duty_b = duty_b;
  ref.duty_c = duty_c;

  SetDuty(&ref);
  
  //  move out of ISR-- AdiMonitor();  // Call monitor program to capture data
}
/* End Of File */


