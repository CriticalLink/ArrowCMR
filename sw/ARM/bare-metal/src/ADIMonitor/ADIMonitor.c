/*****************************************************************************
Copyright (c) 2018 - Analog Devices Inc. All Rights Reserved.
This software is proprietary & confidential to Analog Devices, Inc.
and its licensors.
******************************************************************************
File Name : adimonitor.c

Generation Date: 2018-11-27
Generated By: Jens Sorensen, ADI

Description: This file implements ADIMonitor for Xilinx Zynq. The code executes
on one of the A9s.

*****************************************************************************/
/*=============  I N C L U D E S   =============*/
#include "ADIMonitor.h"
#include "rtwtypes.h"
#include <PMSMctrl.h>          // Header file of auto generated code
#include "platform.h"
#include "application.h"
#include <stdint.h>
#include <stdio.h>

#include "socal/alt_uart.h"
#include "socal/hps.h"
#include "socal/socal.h"

#include <alt_interrupt.h>

/*=============  D E F I N E S   =============*/

#define MAX_NO_OF_BUF	8
#define TX_BUF_SIZE_MAX 1700
#define RX_BUF_SIZE	100

#define RE_EXP_START    255
#define RE_EXP_TYPE     0
#define RE_EXP_DATA     254

#define DOWN_SAMPLING   52
#define NO_OF_BUFFERS   53
#define UPDATE_MICRO    54
#define BUFFER_LENGTH   64
#define TRANSMIT_STATE	65

#define TRIGMODE_SINGLE 203
#define TRIGMODE_AUTO   201
#define SETTRIGDELAY    204
#define TRIG_ARM        205

#define CONFIG	        70
#define SYS_CMD         80
#define MOTOR_START		81
#define MOTOR_STOP		82
#define SET_SPEED       90

#define BAUD_RATE       57600

typedef enum { AUTO,
               SINGLE } trigger_types;

/*=============  P R O T O T Y P E S =============*/
void dump_buffer_to_uart(void);
void reset_monitor(void);
void RxISR(uint8_t);

/*=============  D A T A  =============*/
int32_t UART_TxIsrCounter = 0, UART_RxIsrCounter = 0;
uint16_t CAPTURE_DATA = false;
trigger_types trigger = AUTO;
uint16_t dwn_smp_factor = 1;
uint16_t smp_cnt = 0;
uint16_t capt_ptr = 1;
uint16_t buf_idx = 1;
uint16_t buf_no = 1;
uint16_t start_idx = 0;
uint16_t ready_for_trigger = 0;
uint8_t monitor_tx_buf[TX_BUF_SIZE_MAX];   /* Buffer for data to be transmitted  */
uint8_t monitor_tx_buf_reshuffled[TX_BUF_SIZE_MAX];   /* Buffer for data to be transmitted  */
uint8_t monitor_rx_buf[RX_BUF_SIZE];	   /* Buffer for data to be received */

uint16_t buffer_length = 1;
uint16_t tx_buf_size = 1;
uint16_t length_after_trig = 1;
// Initialized to valid variable address so we can test readback more easily
uint32_t adr_for_capture_variables[MAX_NO_OF_BUF] = {(uint32_t)&UART_RxIsrCounter};   /* Vector containing the address of the memory to monitor */
uint8_t re_expect = RE_EXP_START;

uint8_t triggered = 0;                     /* Current trigger status */
uint8_t trigger_armed = 0;
uint16_t delay = 0;                        /* Trigger delay */
uint8_t GUI_READY = false;

/* The following counters are used to determine when the entire buffer has been sent and received */
volatile int TotalReceivedCount;
volatile int TotalSentCount;
int TotalErrorCount;

void Uart0Isr(uint32_t icciar, void* context) {
/*****************************************************************************
Function: Uart0Isr

Parameters: N/A

Returns: None

Notes: This is a replacement for UartCallback, as the Altera UART does not
 have a higher level wrapper as the Xilinx one did.
*****************************************************************************/

  uint32_t lsr = alt_read_word(ALT_UART0_LSR_ADDR);

  if (ALT_UART_LSR_DR_GET(lsr) == ALT_UART_LSR_DR_E_DATARDY) {
    // Get all data from receive buffer
    do {
      UART_RxIsrCounter++;
      RxISR(alt_read_word(ALT_UART0_RBR_THR_DLL_ADDR));
    } while (ALT_UART_LSR_DR_GET(alt_read_word(ALT_UART0_LSR_ADDR)) == ALT_UART_LSR_DR_E_DATARDY);
  }

  if (ALT_UART_LSR_OE_GET(lsr) == ALT_UART_LSR_OE_E_OVERRUN) {
    TotalErrorCount++;
  }

  if (ALT_UART_LSR_PE_GET(lsr) == ALT_UART_LSR_PE_E_PARITYERR) {
    TotalErrorCount++;
  }

  if (ALT_UART_LSR_PE_GET(lsr) == ALT_UART_LSR_PE_E_PARITYERR) {
    TotalErrorCount++;
  }

  if (ALT_UART_LSR_FE_GET(lsr) == ALT_UART_LSR_FE_E_FRMERR) {
    TotalErrorCount++;
  }

  if (ALT_UART_LSR_FE_GET(lsr) == ALT_UART_LSR_FE_E_FRMERR) {
    TotalErrorCount++;
  }

  if (ALT_UART_LSR_THRE_GET(lsr) == 1) {
    UART_TxIsrCounter++;
  }

  if (ALT_UART_LSR_RFE_GET(lsr) == ALT_UART_LSR_RFE_E_ERR) {
    TotalErrorCount++;
  }
}

void aAdiMonitorInit(void){
/*****************************************************************************
Function: aAdiMonitorInit

Parameters: None

Returns: None

Notes: Setup of UART, ADIMonotor and IRQ controller.
*****************************************************************************/

  CAPTURE_DATA=true;
  smp_cnt=0;
  trigger = AUTO;
  capt_ptr=1;
  start_idx = 1;
  UART_RxIsrCounter = 0;
  UART_TxIsrCounter = 0;

  //Configuration parameters
  dwn_smp_factor = 1;   // Down sampling factor
  buf_no = 2;           // Number of buffers
  buffer_length = 10;
  tx_buf_size = buffer_length * buf_no + 1;
  GUI_READY = false;
  monitor_tx_buf[0]=0xAA;
  monitor_tx_buf_reshuffled[0]=0xAA;

  // Init configuration variables
  PMSMctrl_P.SYSTEM_CMD = 0;		// Set to 1 for auto-start
  PMSMctrl_P.VF_GAIN = 40;
  PMSMctrl_P.VF_BOOST = 0;
  PMSMctrl_P.MAX_RPM = 3000;
  PMSMctrl_P.VF_MAX_RATE = 10;
  PMSMctrl_P.VF_CTRL = 0;
  PMSMctrl_P.ROT_DIR = 0;
  PMSMctrl_P.SPEED_REF = 0;
  PMSMctrl_P.POS_REF = 0;
  PMSMctrl_P.iqMax = 2.0;
  PMSMctrl_P.iqMin = -PMSMctrl_P.iqMax;

  printf("Motor Demo Bare Metal App starting.\r\n");
  printf("Please connect to MATLAB application for further communications at 56700 baud rate.\r\n");

  // Change UART baud rate from default (115200) to expected (57600):
  // Make it so we have access to baud rate divisor
  uint32_t lcr = alt_read_word(ALT_UART0_LCR_ADDR);
  lcr |= ALT_UART_LCR_DLAB_SET_MSK;
  alt_write_word(ALT_UART0_LCR_ADDR, lcr);
  // Read baud rate divisor
  uint32_t div = alt_read_word(ALT_UART0_RBR_THR_DLL_ADDR);
  // Double baud rate divisor to take us from 115200 to 57600
  alt_write_word(ALT_UART0_RBR_THR_DLL_ADDR, div*2);
  // Disable access to baud rate divisor so that UART functions again
  lcr &= ALT_UART_LCR_DLAB_CLR_MSK;
  alt_write_word(ALT_UART0_LCR_ADDR, lcr);

  // Setup interrupt for UART
  alt_write_word(ALT_UART0_IER_DLH_ADDR, 0);

  alt_int_isr_register(ALT_INT_INTERRUPT_UART0, Uart0Isr, NULL);
  int target = 0x1; /* 1 = CPU0, 2=CPU1 */ 
  alt_int_dist_target_set(ALT_INT_INTERRUPT_UART0, target);
  alt_int_dist_enable(ALT_INT_INTERRUPT_UART0);

  // Enable interrupts for UART
  alt_write_word(ALT_UART0_IER_DLH_ADDR, ALT_UART_IER_DLH_ERBFI_DLH0_SET_MSK);

  // Enable Tx and Rx FIFOs
  alt_write_word(ALT_UART0_FCR_ADDR, ALT_UART_FCR_FIFOE_SET_MSK);
}

void AdiMonitor(void){
/*****************************************************************************
  Function: AdiMonitor

  Parameters: None

  Returns: None

  Notes: Call this function from the application. Should be called at a fixed
         rate after assignment of I/Os.
*****************************************************************************/
    uint16_t i;
    uint8_t *pointer_for_capture_variable;

    if(CAPTURE_DATA && GUI_READY){  // Only capture when transmission is not in progress. If transmission in progress, just return.
      smp_cnt++;
      if(smp_cnt >= dwn_smp_factor){
        smp_cnt=0;

        for ( i=0; i < buf_no; i++){
          pointer_for_capture_variable = (uint8_t *) adr_for_capture_variables[i];
          monitor_tx_buf[capt_ptr] = *pointer_for_capture_variable; /* Capture data at the selected addresses */
          buf_idx++;
          capt_ptr++;
          if(capt_ptr == TX_BUF_SIZE_MAX)
            capt_ptr = 1;
        }

        switch(trigger){
          case AUTO:
            if(buf_idx >= tx_buf_size){
              start_idx = 1;
              capt_ptr = 1;
	      if(GUI_READY) // If GUI ready, start streaming. Else start over.
                dump_buffer_to_uart();
            }
            break;

          case SINGLE:
            if(buf_idx>(delay * buf_no))
              ready_for_trigger = 1;
            if(triggered && trigger_armed){
              if (buf_idx >= length_after_trig){
                dump_buffer_to_uart();
                triggered = 0;
                trigger_armed = 0;
              }
            }
            break;
        }
      }
   }
}

void TrigAdiMonitor(void){
/*****************************************************************************
Function: TrigAdiMonitor

Parameters: None

Returns: None

Notes: Call this function to trigger ADIMonitor in SINGLE mode
*****************************************************************************/
  if(trigger == SINGLE && triggered == 0 && ready_for_trigger == 1){    // To accept trigger make sure we are using SINGLE trigger, trigger has not already happend once and that the GUI is ready to accept data
    triggered = 1;
    start_idx = capt_ptr;
    if (delay<buffer_length)    // To make sure delay does not over run physical length of buffer
      length_after_trig = (tx_buf_size) - delay * buf_no;
    else
      length_after_trig = 1;

    buf_idx = 1;                // Indicate we are starting to capture now
  }
}

static void uart_send(const uint8_t* data, uint32_t numBytes) {
  for (int idx = 0; idx < numBytes; idx++) {
    // Make sure there is room in transmit FIFO
    while(1 != ALT_UART_LSR_THRE_GET(alt_read_word(ALT_UART0_LSR_ADDR)))
    {
    }

    // Write to transmit FIFO
    alt_write_word(ALT_UART0_RBR_THR_DLL_ADDR, data[idx]);
  }
}

void dump_buffer_to_uart(void){
/*****************************************************************************
  Function: dump_buffer_to_uart

  Parameters: None

  Returns: None

  Notes: Call this function when data are ready to TX.
*****************************************************************************/
  uint16_t idx = 1;
  uint16_t buffer_cnt = 1;

  CAPTURE_DATA = false;      // Tell monitor to stop capturing while transmit in going on.
  monitor_tx_buf[0]=0xAA;    // GUI expects 0xAA as first char.
  monitor_tx_buf_reshuffled[0]=0xAA;

  if(trigger == SINGLE){	 // If single trigger we have to reshuffle buffer before submitting
    if(start_idx > (delay * buf_no))
      buffer_cnt = start_idx - (delay * buf_no);
    else
      buffer_cnt = TX_BUF_SIZE_MAX-1 - (delay * buf_no) + start_idx;

    for ( idx=1; idx<TX_BUF_SIZE_MAX; idx++){
      monitor_tx_buf_reshuffled[idx]=monitor_tx_buf[buffer_cnt];
      buffer_cnt++;
      if(buffer_cnt>=TX_BUF_SIZE_MAX)
        buffer_cnt=1;
    }
    uart_send(monitor_tx_buf_reshuffled, tx_buf_size);
  }
  else{
    uart_send(monitor_tx_buf, tx_buf_size);
  }
}

void RxISR(uint8_t rx_data){
/*****************************************************************************
  Function: RxISR

  Parameters: Received RX byte (one at a time)

  Returns: None

  Notes: Call this function when data have been received and are ready to process.

*****************************************************************************/
  static uint8_t re_type=DOWN_SAMPLING, no_of_received_bytes, ch_no;
  static uint8_t received_adr[4];
  static uint16_t buffer_length_temp, imax_temp, max_rpm_temp;
  static uint16_t delay_temp, speed_temp;
  uint32_t address_temp=0;

  switch(re_expect){
    case RE_EXP_START:
      if(rx_data==RE_EXP_START) 
         re_expect = RE_EXP_TYPE;	/* A start byte has been received */
    break;

    case RE_EXP_TYPE:
         re_type=rx_data;			/* A type byte has been received */
         re_expect=RE_EXP_DATA;
         no_of_received_bytes = 0;
	 break;

    case RE_EXP_DATA:               /* Receiving data */
      switch(re_type){              /* What kind of data? */
         case DOWN_SAMPLING:
           dwn_smp_factor=rx_data;
           re_expect=RE_EXP_START;
         break;

   	    case TRANSMIT_STATE:
            GUI_READY = rx_data;
	    if(GUI_READY)				// If GUI is ready, reset everything so we can start a new capture.
	      reset_monitor();
	    else
          re_expect=RE_EXP_START;
        break;

      case UPDATE_MICRO:			/* Update micro with the new memory addresses that have to be sampled */
        if ( no_of_received_bytes == 0){
          ch_no = rx_data;
        }
        else
          received_adr[no_of_received_bytes-1] = rx_data;

        no_of_received_bytes++;
        if ( no_of_received_bytes > 4){
	      address_temp=received_adr[0];
    	  address_temp=address_temp<<8;
	      address_temp=address_temp+received_adr[1];
	      address_temp=address_temp<<8;
	      address_temp=address_temp+received_adr[2];
	      address_temp=address_temp<<8;
	      address_temp=address_temp+received_adr[3];

	      adr_for_capture_variables[ch_no]=address_temp;

    	  re_expect=RE_EXP_START;
          reset_monitor();
        }
      break;

      case NO_OF_BUFFERS:
        buf_no = rx_data;
        re_expect=RE_EXP_START;
        reset_monitor();
      break;

      case TRIGMODE_AUTO:
	    trigger=AUTO;
        re_expect=RE_EXP_START;
        reset_monitor();
      break;

      case TRIGMODE_SINGLE:  // Do a reset_monitor() here except CAPTURE_DATA = TRUE
	    trigger=SINGLE;		 // If trigger is armed and active while transmitting, the buffer gets messes up. Wait for GUI ot set  CAPTURE_DATA = TRUE
	    triggered = 0;
        trigger_armed = 1;
        ready_for_trigger = 0;
        buf_idx = 1;
        smp_cnt = 0;
        capt_ptr = 1;
        start_idx = 1;
        monitor_tx_buf[0]=0xAA;
        monitor_tx_buf_reshuffled[0]=0xAA;
        re_expect=RE_EXP_START;
      break;

      case SETTRIGDELAY:
        if (no_of_received_bytes == 0){
          no_of_received_bytes++;
          delay_temp = rx_data;
        }
        else{
          delay = (delay_temp<<8) + rx_data;
          re_expect=RE_EXP_START;
        }
      break;

      case BUFFER_LENGTH:
        if (no_of_received_bytes == 0){
          no_of_received_bytes++;
          buffer_length_temp = rx_data;
        }
        else{
          buffer_length = (buffer_length_temp<<8) + rx_data;
          re_expect=RE_EXP_START;
          reset_monitor();
        }
      break;

	case CONFIG:
	    if (no_of_received_bytes == 0)			// VF_GAIN
              PMSMctrl_P.VF_GAIN = rx_data;
            else if (no_of_received_bytes == 1)	// V_BOOST
              PMSMctrl_P.VF_BOOST = rx_data;
	    else if (no_of_received_bytes == 2)		// I_MAX high
	      imax_temp = rx_data;
	    else if (no_of_received_bytes == 3){    // I_MAX low
              imax_temp = (imax_temp<<8) + rx_data;
              PMSMctrl_P.iqMax = ((real32_t)imax_temp*20.0)/65536.0;
              PMSMctrl_P.iqMin = -PMSMctrl_P.iqMax;
            }
	    else if (no_of_received_bytes == 4)		// MAX_RPM high
              max_rpm_temp = rx_data;
	    else if (no_of_received_bytes == 5) 	// MAX_RPM
              PMSMctrl_P.MAX_RPM = (max_rpm_temp<<8) + rx_data;
	    else if (no_of_received_bytes == 6) 	//VF_MAX_RATE
              PMSMctrl_P.VF_MAX_RATE = rx_data;
	    else if (no_of_received_bytes == 7)		// POLE_PAIR
              PMSMctrl_P.VF_CTRL = rx_data;
	    else{									// ROT_DIR
	        PMSMctrl_P.ROT_DIR = rx_data;
            re_expect = RE_EXP_START;
	    }
	    no_of_received_bytes++;
        break;

	case SYS_CMD:
          if(rx_data==MOTOR_START){
	         PMSMctrl_P.SYSTEM_CMD=1;
             aAppCmd(eAPP_START);
          }
          else{
	      PMSMctrl_P.SYSTEM_CMD = 0;
            aAppCmd(eAPP_STOP);
          }
	  re_expect = RE_EXP_START;
        break;

	case SET_SPEED:
	    if (no_of_received_bytes == 0){
              no_of_received_bytes++;
              speed_temp = rx_data;
            }
            else{
              PMSMctrl_P.SPEED_REF = (speed_temp<<8) + rx_data;
              PMSMctrl_P.POS_REF = (float)PMSMctrl_P.SPEED_REF;
              re_expect=RE_EXP_START;
            }
        break;
      }
      break;
    }
}

void reset_monitor(void){
/*****************************************************************************
  Function: reset_monitor

  Parameters:

  Returns: None

*****************************************************************************/
  buf_idx = 1;
  smp_cnt = 0;
  capt_ptr = 1;
  start_idx = 1;
  CAPTURE_DATA = true;
  monitor_tx_buf[0]=0xAA;
  monitor_tx_buf_reshuffled[0]=0xAA;
  ready_for_trigger = 0;

  if (buf_no > MAX_NO_OF_BUF)
    buf_no = MAX_NO_OF_BUF;

  if ( buf_no == 0)
    buf_no = 1;

  if (buffer_length > TX_BUF_SIZE_MAX)
    buffer_length = TX_BUF_SIZE_MAX;

  tx_buf_size = buf_no * buffer_length + 1; // The '1' is to make room for start byte 0xAA

  if (TX_BUF_SIZE_MAX < tx_buf_size){
    buffer_length = (TX_BUF_SIZE_MAX - MAX_NO_OF_BUF)/buf_no;
    tx_buf_size = buf_no * buffer_length + 1;
  }
}
