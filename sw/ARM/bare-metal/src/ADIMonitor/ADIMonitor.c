/*****************************************************************************
Copyright (c) 2018 - Analog Devices Inc. All Rights Reserved.
This software is proprietary & confidential to Analog Devices, Inc.
and its licensors.
******************************************************************************
File Name : adimonitor.c

Generation Date: 2018-11-27
Generated By: Jens Sorensen

Description: This file implements ADIMonitor for Xilinx Zynq. The code executes
on one of the A9s.

*****************************************************************************/
/*=============  I N C L U D E S   =============*/
#include "ADIMonitor.h"
#include "rtwtypes.h"
#include <PMSMctrl.h>          // Header file of auto generated code
#include "platform.h"
#include "application.h"
#include "motor_control.h"
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "socal/alt_uart.h"
#include "socal/hps.h"
#include "socal/socal.h"

#include <alt_interrupt.h>
#include <alt_generalpurpose_io.h>
#include "hwlib.h"
#include "alt_16550_uart.h"
#include "alt_16550_buffer.h"

/*=============  D E F I N E S   =============*/

#define MAX_NO_OF_BUF	8
#define TX_BUF_SIZE_MAX 1700
#define RX_BUF_SIZE	100

#define RE_EXP_START    255
#define RE_EXP_TYPE     0
#define RE_EXP_DATA     254

#define DOWN_SAMPLING   52
#define NO_OF_BUFFERS   53
#define UPDATE_MICRO    54
#define BUFFER_LENGTH   64
#define TRANSMIT_STATE	65

#define TRIGMODE_SINGLE 203
#define TRIGMODE_AUTO   201
#define SETTRIGDELAY    204
#define TRIG_ARM        205

#define CONFIG	        70
#define SYS_CMD         80
#define MOTOR_START		81
#define MOTOR_STOP		82
#define SET_SPEED       90

typedef enum { AUTO,
               SINGLE } trigger_types;

/*=============  P R O T O T Y P E S =============*/
void dump_buffer_to_uart(void);
static int NeedReset = 1;
void reset_monitor(void) {
	NeedReset = 1;
}
void do_reset_monitor(void);
void RxISR(uint8_t);

/*=============  D A T A  =============*/
int32_t UART_TxIsrCounter = 0, UART_RxIsrCounter = 0;
uint16_t CAPTURE_DATA = false;
trigger_types trigger = AUTO;
uint16_t dwn_smp_factor = 1;
uint16_t smp_cnt = 0;
uint16_t capt_ptr = 1;
uint16_t buf_idx = 1;
uint16_t buf_no = 1;
uint16_t start_idx = 0;
uint16_t ready_for_trigger = 0;
uint8_t monitor_tx_buf[TX_BUF_SIZE_MAX];   /* Buffer for data to be transmitted  */
uint8_t monitor_tx_buf_reshuffled[TX_BUF_SIZE_MAX];   /* Buffer for data to be transmitted  */
uint8_t monitor_rx_buf[RX_BUF_SIZE];	   /* Buffer for data to be received */

uint16_t buffer_length = 1;
uint16_t tx_buf_size = 1;
uint16_t length_after_trig = 1;
// Initialized to valid variable address so we can test readback more easily
volatile uint32_t adr_for_capture_variables[MAX_NO_OF_BUF] = {(uint32_t)&UART_RxIsrCounter};   /* Vector containing the address of the memory to monitor */
uint8_t re_expect = RE_EXP_START;

uint8_t triggered = 0;                     /* Current trigger status */
uint8_t trigger_armed = 0;
uint16_t delay = 0;                        /* Trigger delay */
uint8_t GUI_READY = false;

/* The following counters are used to determine when the entire buffer has been sent and received */
volatile int TotalReceivedCount;
volatile int TotalSentCount;
static int TotalErrorCount=0;

ALT_STATUS_CODE aAdiMonitorInit(void){
/*****************************************************************************
Function: aAdiMonitorInit

Parameters: None

Returns: None

Notes: Setup of UART, ADIMonotor and IRQ controller.
*****************************************************************************/

  CAPTURE_DATA=true;
  smp_cnt=0;
  trigger = AUTO;
  capt_ptr=1;
  start_idx = 1;
  UART_RxIsrCounter = 0;
  UART_TxIsrCounter = 0;
  ALT_STATUS_CODE status =ALT_E_SUCCESS;

  //Configuration parameters
  dwn_smp_factor = 1;   // Down sampling factor
  buf_no = 2;           // Number of buffers
  buffer_length = 10;
  tx_buf_size = buffer_length * buf_no + 1;
  GUI_READY = false;
  monitor_tx_buf[0]=0xAA;
  monitor_tx_buf_reshuffled[0]=0xAA;

  // Init configuration variables
  PMSMctrl_P.SYSTEM_CMD = 0;		// Set to 1 for auto-start
  PMSMctrl_P.VF_GAIN = 40;
  PMSMctrl_P.VF_BOOST = 0;
  PMSMctrl_P.MAX_RPM = 3000;
  PMSMctrl_P.VF_MAX_RATE = 10;
  PMSMctrl_P.ROT_DIR = 0;
  PMSMctrl_P.SPEED_REF = 0;
  PMSMctrl_P.POS_REF = 0;
  
  aMcModeHandler(0);

  return status;
}

void checkRxUart(void) {
    char read_buff[1];
    size_t bytes_to_read = sizeof(read_buff);
    size_t bytes_read = 0;
    uint32_t bytes_available = 0;
    alt_16550_buffer_level_rx(&g_uart0_buffer, &bytes_available);

    while(bytes_available) {
    	// check if data has been received from UART and process
    	if(ALT_E_SUCCESS == alt_16550_buffer_read_raw(&g_uart0_buffer,read_buff, bytes_to_read, &bytes_read)) {
    		if(bytes_to_read == bytes_read) {
    			RxISR(read_buff[0]);
    		}
    	}
    	--bytes_available;
    }
}
void AdiMonitor(void){
/*****************************************************************************
  Function: AdiMonitor

  Parameters: None

  Returns: None

  Notes: Call this function from the application. Should be called at a fixed
         rate after assignment of I/Os.
*****************************************************************************/
    uint16_t i;
    volatile uint8_t *pointer_for_capture_variable;

    int ok_to_capture = CAPTURE_DATA && GUI_READY;

    if(NeedReset) {
    	do_reset_monitor();
    }
    SetLed(GPIO_LED3,ok_to_capture);
    if(ok_to_capture){  // Only capture when transmission is not in progress. If transmission in progress, just return.
      smp_cnt++;
      if(smp_cnt >= dwn_smp_factor){
        smp_cnt=0;

        for ( i=0; i < buf_no; i++){
        	pointer_for_capture_variable = (volatile uint8_t *) adr_for_capture_variables[i];
        	monitor_tx_buf[capt_ptr] = *pointer_for_capture_variable; /* Capture data at the selected addresses */
        	buf_idx++;
        	capt_ptr++;
        	if(capt_ptr == TX_BUF_SIZE_MAX)
        		capt_ptr = 1;
        }

        switch(trigger){
          case AUTO:
            if(buf_idx >= tx_buf_size){
              start_idx = 1;
              capt_ptr = 1;
	      if(GUI_READY) // If GUI ready, start streaming. Else start over.
                dump_buffer_to_uart();
            }
            break;

          case SINGLE:
            if(buf_idx>(delay * buf_no))
              ready_for_trigger = 1;
            if(triggered && trigger_armed){
              if (buf_idx >= length_after_trig){
                dump_buffer_to_uart();
                triggered = 0;
                trigger_armed = 0;
              }
            }
            break;
        }
      }
   }
}

void TrigAdiMonitor(void){
/*****************************************************************************
Function: TrigAdiMonitor

Parameters: None

Returns: None

Notes: Call this function to trigger ADIMonitor in SINGLE mode
*****************************************************************************/
  if(trigger == SINGLE && triggered == 0 && ready_for_trigger == 1){    // To accept trigger make sure we are using SINGLE trigger, trigger has not already happend once and that the GUI is ready to accept data
    triggered = 1;
    start_idx = capt_ptr;
    if (delay<buffer_length)    // To make sure delay does not over run physical length of buffer
      length_after_trig = (tx_buf_size) - delay * buf_no;
    else
      length_after_trig = 1;

    buf_idx = 1;                // Indicate we are starting to capture now
  }
}

static void uart_send(const uint8_t* data, uint32_t numBytes) {

	size_t bytes_written = 0;
	ALT_STATUS_CODE status = alt_16550_buffer_write_raw(&g_uart0_buffer, (char*)data, (size_t)numBytes, &bytes_written);
	if(ALT_E_SUCCESS != status || (bytes_written != numBytes)) {
		++TotalErrorCount;
	}
	if(0!=TotalErrorCount)
		SetLed(GPIO_LED6, 1);
}

void dump_buffer_to_uart(void){
/*****************************************************************************
  Function: dump_buffer_to_uart

  Parameters: None

  Returns: None

  Notes: Call this function when data are ready to TX.
*****************************************************************************/
  uint16_t idx = 1;
  uint16_t buffer_cnt = 1;
  SetLed(GPIO_LED5, 1);

  CAPTURE_DATA = false;      // Tell monitor to stop capturing while transmit in going on.
  monitor_tx_buf[0]=0xAA;    // GUI expects 0xAA as first char.
  monitor_tx_buf_reshuffled[0]=0xAA;

  if(trigger == SINGLE){	 // If single trigger we have to reshuffle buffer before submitting
    if(start_idx > (delay * buf_no))
      buffer_cnt = start_idx - (delay * buf_no);
    else
      buffer_cnt = TX_BUF_SIZE_MAX-1 - (delay * buf_no) + start_idx;

    for ( idx=1; idx<TX_BUF_SIZE_MAX; idx++){
      monitor_tx_buf_reshuffled[idx]=monitor_tx_buf[buffer_cnt];
      buffer_cnt++;
      if(buffer_cnt>=TX_BUF_SIZE_MAX)
        buffer_cnt=1;
    }
    uart_send(monitor_tx_buf_reshuffled, tx_buf_size);
  }
  else{
    uart_send(monitor_tx_buf, tx_buf_size);
  }
  SetLed(GPIO_LED5, 0);
}

void RxISR(uint8_t rx_data){
/*****************************************************************************
  Function: RxISR

  Parameters: Received RX byte (one at a time)

  Returns: None

  Notes: Call this function when data have been received and are ready to process.

*****************************************************************************/
  static uint8_t re_type=DOWN_SAMPLING, no_of_received_bytes, ch_no;
  static uint8_t received_adr[4];
  static uint16_t buffer_length_temp, imax_temp, max_rpm_temp;
  static uint16_t delay_temp, speed_temp;
  uint32_t address_temp=0;

  switch(re_expect){
    case RE_EXP_START:
      if(rx_data==RE_EXP_START) {
         re_expect = RE_EXP_TYPE;	/* A start byte has been received */
      }
    break;

    case RE_EXP_TYPE:
         re_type=rx_data;			/* A type byte has been received */
         re_expect=RE_EXP_DATA;
         no_of_received_bytes = 0;
	 break;

    case RE_EXP_DATA:               /* Receiving data */
      switch(re_type){              /* What kind of data? */
         case DOWN_SAMPLING:
           dwn_smp_factor=rx_data;
           re_expect=RE_EXP_START;
         break;

   	    case TRANSMIT_STATE:
            GUI_READY = rx_data;
	    if(GUI_READY)				// If GUI is ready, reset everything so we can start a new capture.
	      reset_monitor();
	    else
          re_expect=RE_EXP_START;
        break;

      case UPDATE_MICRO:			/* Update micro with the new memory addresses that have to be sampled */
        if ( no_of_received_bytes == 0){
          ch_no = rx_data;
        }
        else
          received_adr[no_of_received_bytes-1] = rx_data;

        no_of_received_bytes++;
        if ( no_of_received_bytes > 4){
	      address_temp=received_adr[0];
    	  address_temp=address_temp<<8;
	      address_temp=address_temp+received_adr[1];
	      address_temp=address_temp<<8;
	      address_temp=address_temp+received_adr[2];
	      address_temp=address_temp<<8;
	      address_temp=address_temp+received_adr[3];

	      adr_for_capture_variables[ch_no]=address_temp;

    	  re_expect=RE_EXP_START;
          reset_monitor();
        }
      break;

      case NO_OF_BUFFERS:
        buf_no = rx_data;
        re_expect=RE_EXP_START;
        reset_monitor();
      break;

      case TRIGMODE_AUTO:
	    trigger=AUTO;
        re_expect=RE_EXP_START;
        reset_monitor();
      break;

      case TRIGMODE_SINGLE:  // Do a reset_monitor() here except CAPTURE_DATA = TRUE
	    trigger=SINGLE;		 // If trigger is armed and active while transmitting, the buffer gets messes up. Wait for GUI ot set  CAPTURE_DATA = TRUE
	    triggered = 0;
        trigger_armed = 1;
        ready_for_trigger = 0;
        buf_idx = 1;
        smp_cnt = 0;
        capt_ptr = 1;
        start_idx = 1;
        monitor_tx_buf[0]=0xAA;
        monitor_tx_buf_reshuffled[0]=0xAA;
        re_expect=RE_EXP_START;
      break;

      case SETTRIGDELAY:
        if (no_of_received_bytes == 0){
          no_of_received_bytes++;
          delay_temp = rx_data;
        }
        else{
          delay = (delay_temp<<8) + rx_data;
          re_expect=RE_EXP_START;
        }
      break;

      case BUFFER_LENGTH:
        if (no_of_received_bytes == 0){
          no_of_received_bytes++;
          buffer_length_temp = rx_data;
        }
        else{
          buffer_length = (buffer_length_temp<<8) + rx_data;
          re_expect=RE_EXP_START;
          reset_monitor();
        }
      break;

	case CONFIG:
	    if (no_of_received_bytes == 0)			// VF_GAIN
              PMSMctrl_P.VF_GAIN = rx_data;
            else if (no_of_received_bytes == 1)	// V_BOOST
              PMSMctrl_P.VF_BOOST = rx_data;
	    else if (no_of_received_bytes == 2)		// I_MAX high
	      imax_temp = rx_data;
	    else if (no_of_received_bytes == 3){    // I_MAX low
              imax_temp = (imax_temp<<8) + rx_data;
              PMSMctrl_P.iqMax = ((real32_t)imax_temp*20.0)/65536.0;
              PMSMctrl_P.iqMin = -PMSMctrl_P.iqMax;
            }
	    else if (no_of_received_bytes == 4)		// MAX_RPM high
              max_rpm_temp = rx_data;
	    else if (no_of_received_bytes == 5) 	// MAX_RPM
              PMSMctrl_P.MAX_RPM = (max_rpm_temp<<8) + rx_data;
	    else if (no_of_received_bytes == 6) 	//VF_MAX_RATE
              PMSMctrl_P.VF_MAX_RATE = rx_data;
	    else if (no_of_received_bytes == 7)		// VF_CTRL
	    	  aMcModeHandler(rx_data);
	    else{									// ROT_DIR
	        PMSMctrl_P.ROT_DIR = rx_data;
            re_expect = RE_EXP_START;
	    }
	    no_of_received_bytes++;
        break;

	case SYS_CMD:
          if(rx_data==MOTOR_START){
	         PMSMctrl_P.SYSTEM_CMD=1;
             aAppCmd(eAPP_START);
          }
          else{
	      PMSMctrl_P.SYSTEM_CMD = 0;
            aAppCmd(eAPP_STOP);
          }
	  re_expect = RE_EXP_START;
        break;

	case SET_SPEED:
	    if (no_of_received_bytes == 0){
              no_of_received_bytes++;
              speed_temp = rx_data;
            }
            else{
              PMSMctrl_P.SPEED_REF = (speed_temp<<8) + rx_data;
              PMSMctrl_P.POS_REF = (float)PMSMctrl_P.SPEED_REF;
              re_expect=RE_EXP_START;
            }
        break;
      }
      break;
    }
}

/*****************************************************************************
  Function: reset_monitor

  Parameters:

  Returns: None

*****************************************************************************/
void do_reset_monitor(void){
  NeedReset = 0;
  buf_idx = 1;
  smp_cnt = 0;
  capt_ptr = 1;
  start_idx = 1;
  CAPTURE_DATA = true;
  monitor_tx_buf[0]=0xAA;
  monitor_tx_buf_reshuffled[0]=0xAA;
  ready_for_trigger = 0;
  re_expect = RE_EXP_START;

  for(int ii = 1; ii < TX_BUF_SIZE_MAX; ++ii) {
	  monitor_tx_buf[ii] = 10.0;
	    monitor_tx_buf_reshuffled[ii] = 20.0;
  }
  if (buf_no > MAX_NO_OF_BUF)
    buf_no = MAX_NO_OF_BUF;

  if ( buf_no == 0)
    buf_no = 1;

  if (buffer_length > TX_BUF_SIZE_MAX)
    buffer_length = TX_BUF_SIZE_MAX;

  tx_buf_size = buf_no * buffer_length + 1; // The '1' is to make room for start byte 0xAA

  if (TX_BUF_SIZE_MAX < tx_buf_size){
    buffer_length = (TX_BUF_SIZE_MAX - MAX_NO_OF_BUF)/buf_no;
    tx_buf_size = buf_no * buffer_length + 1;
  }
}


void checkTxBuffer(void)
{
	uint32_t level = 0;
	ALT_STATUS_CODE status = alt_16550_buffer_level_tx(&g_uart0_buffer, &level);
	if(status == ALT_E_SUCCESS) {
		if (level > 0) {
			status = alt_16550_do_tx(&g_uart0_buffer);
		}
	}
}
